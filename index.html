<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover" />
<title>雙計時器 · 配方 + PWA + 常亮 / Dual Timers · Recipes + PWA + Wake Lock</title>
<meta name="theme-color" content="#0b1020">
<style>
  :root {
    --bg:#0b1020; --card:#121a33; --ink:#e9eefc; --muted:#95a1c4; --accent:#6aa9ff; --warn:#ffb86b; --ok:#46d39a;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto; color:var(--ink); background:linear-gradient(180deg,#0a0f1e,#0d1326);}
  .wrap{max-width:1200px; margin:0 auto; padding:12px;}
  .title{font-weight:800; font-size:22px; letter-spacing:.3px; margin:8px 0}
  .sub{color:var(--muted); margin-bottom:10px}
  .en{display:block; font-size:12px; color:var(--muted)}
  .badge{font-size:12px; color:#0b1020; background:var(--warn); border-radius:8px; padding:2px 8px; display:inline-block}
  .pill{padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:#0c1430; color:var(--ink); display:inline-flex; gap:8px; align-items:center}
  button{padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:#0f1a3b; color:var(--ink); cursor:pointer; font-weight:600}
  button.primary{background:linear-gradient(135deg,#4d87ff,#6aa9ff); color:#0a0f1e; border:none}
  button.warn{background:#2b1a05; border:1px solid #ffb86b; color:#ffb86b}
  input[type="number"]{width:64px; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:#0c1430; color:var(--ink); font-size:18px; text-align:center}

  /* Layouts */
  .toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:8px 0 10px}
  .status-bar{display:flex; gap:10px; flex-wrap:wrap; margin:6px 0 10px}
  .big-status{flex:1; min-width:240px; padding:10px 12px; border-radius:12px;
    background:rgba(70,211,154,.12); border:1px solid rgba(70,211,154,.35);
    font-weight:800; font-size:22px; letter-spacing:.5px; display:flex; justify-content:space-between; align-items:center}
  .big-status .subtxt{font-size:13px; color:var(--muted); font-weight:600}
  .kpi{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .strong{color:var(--ok)}

  /* Grid containers that reflow based on layout */
  .container{display:grid; gap:12px}
  .card{background:var(--card); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:12px}
  .card h2{margin:0 0 6px 0; font-size:18px}
  .section-title{font-weight:700; margin:6px 0 6px}

  /* Sliders */
  .slider-row{display:grid; grid-template-columns:120px 1fr auto; gap:10px; align-items:center; margin-top:6px}
  input[type="range"]{width:100%}
  .val{min-width:56px; text-align:right; font-variant-numeric:tabular-nums}
  .time-input{display:flex; align-items:center; gap:6px}
  .choices{display:flex; gap:8px; flex-wrap:wrap; margin-top:6px}
  .choices label{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:#0e1736; cursor:pointer}
  .display{font-variant-numeric:tabular-nums; font-size:48px; font-weight:800; letter-spacing:1px; margin:8px 0 8px}
  .footer{margin:12px 0; font-size:13px; color:var(--muted)}

  /* Responsive layout modes */
  body.landscape .container{grid-template-columns: 1fr 1fr}
  body.landscape .recipe-grid{grid-template-columns: 1.2fr 1fr 1fr auto}
  body.portrait .container{grid-template-columns: 1fr}
  body.portrait .recipe-grid{grid-template-columns: 1fr}

  .recipe-grid{display:grid; gap:8px}
  .recipe-grid input[type="text"], .recipe-grid select{width:100%; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:#0c1430; color:var(--ink)}

  /* Totals row */
  .totals{display:flex; flex-wrap:wrap; gap:8px}
  .totals .pill{font-size:16px}

  /* Orientation hint */
  .hint{color:var(--muted); font-size:12px}
</style>
</head>
<body class="portrait">
<div class="wrap">
  <div class="title">雙計時器｜配方 + PWA + 常亮 / Dual Timers · Recipes + PWA + Wake Lock</div>
  <div class="sub">A/B 交替、臨界嗶聲、對調播報、長休息、配方、一鍵啟動；加入 **總剩餘時間**、**PWA 安裝**、**螢幕常亮**，並支援 **橫/直版切換（自動 + 手動）**。<span class="en">Alternate A/B, critical beeps, swapped speech, long rest, recipes; now with **Total Remaining Time**, **PWA install**, **Screen Wake Lock**, and **Portrait/Landscape layouts (auto + manual)**.</span></div>

  <div class="toolbar">
    <button id="startBtn" class="primary">開始循環<span class="en">Start</span></button>
    <button id="pauseBtn" disabled>暫停<span class="en">Pause</span></button>
    <button id="resetBtn" class="warn">重設<span class="en">Reset</span></button>
    <label class="pill"><input id="vibrateChk" type="checkbox"> 震動提示<span class="en">&nbsp;Vibration</span></label>
    <label class="pill"><input id="wakeChk" type="checkbox"> 螢幕常亮<span class="en">&nbsp;Keep Screen On</span></label>
    <div class="pill">
      版面：<select id="layoutSelect">
        <option value="auto">自動偵測 / Auto</option>
        <option value="portrait">直式 / Portrait</option>
        <option value="landscape">橫式 / Landscape</option>
      </select>
    </div>
    <div id="pwaStatus" class="hint">PWA：偵測中… / Checking…</div>
  </div>

  <div class="status-bar">
    <div class="big-status">
      <span>目前：<span id="who">—</span></span>
      <span class="subtxt">Now</span>
    </div>
    <span class="pill">已完成輪數：<strong id="roundsDone" class="strong">0</strong><span class="en">&nbsp;Rounds Done</span></span>
    <span class="pill">目標輪數：<strong id="roundsGoal">∞</strong><span class="en">&nbsp;Target</span></span>
  </div>

  <div class="totals">
    <span class="pill">本輪剩餘：<strong id="phaseRemain">00:00</strong><span class="en">&nbsp;This Phase Left</span></span>
    <span class="pill">總剩餘：<strong id="totalRemain">00:00</strong><span class="en">&nbsp;Total Remaining</span></span>
  </div>

  <div class="card">
    <h2>配方管理 / Recipe Manager</h2>
    <div class="recipe-grid">
      <div>
        <label>選擇配方<span class="en">Select Recipe</span></label>
        <select id="recipeSelect"></select>
      </div>
      <div>
        <label>配方名稱<span class="en">Recipe Name</span></label>
        <input id="recipeName" type="text" placeholder="例如：Archery SPT × 6 / Tabata 20/10 × 8">
      </div>
      <div style="display:flex; gap:8px; align-items:flex-end;">
        <button id="saveRecipe">儲存/覆蓋<span class="en">Save/Overwrite</span></button>
        <button id="deleteRecipe" class="warn">刪除<span class="en">Delete</span></button>
      </div>
      <div style="display:flex; gap:8px; align-items:flex-end;">
        <button id="startRecipe" class="primary">一鍵啟動當前配方<span class="en">Start Selected Recipe</span></button>
      </div>
    </div>

    <div class="section-title">輪數與長休息 / Rounds & Long Rest</div>
    <div style="display:grid; gap:10px; grid-template-columns:1fr 1fr">
      <div>
        <div class="slider-row">
          <span class="pill">本次輪數 / Rounds</span>
          <input id="roundsSlider" type="range" min="1" max="99" step="1">
          <span class="val" id="roundsVal">8</span>
        </div>
        <div class="pill" style="margin-top:6px">
          <label><input id="autoStopChk" type="checkbox" checked> 自動停止 <span class="en">&nbsp;Auto Stop</span></label>
        </div>
      </div>
      <div>
        <div class="pill" style="margin-bottom:6px">每 N 輪長休 / Long Rest every N rounds</div>
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
          <span class="pill">N</span>
          <input id="longEveryN" type="number" min="0" max="999" value="0">
          <span>長休 M:SS <span class="en">Long Rest M:SS</span></span>
        </div>
        <div class="slider-row">
          <span class="pill">分鐘 / Min</span>
          <input id="longMinSlider" type="range" min="0" max="99" step="1">
          <span class="val" id="longMinVal">00</span>
        </div>
        <div class="slider-row">
          <span class="pill">秒 / Sec</span>
          <input id="longSecSlider" type="range" min="0" max="59" step="1">
          <span class="val" id="longSecVal">00</span>
        </div>
        <div class="time-input" style="margin-top:6px">
          <input id="longMin" type="number" min="0" max="99" value="00">
          <span>:</span>
          <input id="longSec" type="number" min="0" max="59" value="00">
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- A -->
    <div class="card" id="cardA">
      <h2>第一組（A） <span class="en">Timer A</span> <span class="badge" id="badgeA">待命<span class="en"> Ready</span></span></h2>
      <div class="section-title">時間（MM:SS）<span class="en">Duration (MM:SS)</span></div>
      <div class="slider-row">
        <span class="pill">分鐘 / Min</span>
        <input id="minASlider" type="range" min="0" max="99" step="1">
        <span class="val" id="minAVal">00</span>
      </div>
      <div class="slider-row">
        <span class="pill">秒 / Sec</span>
        <input id="secASlider" type="range" min="0" max="59" step="1">
        <span class="val" id="secAVal">20</span>
      </div>
      <div class="time-input"><input id="minA" type="number" min="0" max="99" value="00"><span>:</span><input id="secA" type="number" min="0" max="59" value="20"></div>

      <div class="section-title">嗶聲起點（剩餘秒）<span class="en">Beep when ≤ seconds left</span></div>
      <div class="slider-row">
        <span class="pill">嗶聲 / Beep</span>
        <input id="beepASlider" type="range" min="1" max="10" step="1">
        <span class="val"><span id="beepAVal">5</span>s</span>
      </div>
      <div class="pill" style="margin-top:6px">數字輸入 / Box <input id="beepA" type="number" min="0" max="60" value="5" style="width:64px;margin-left:8px;"></div>

      <div class="section-title">到時播報詞（在「B 組」結束時播）<span class="en">End speech (spoken when B ends)</span></div>
      <div class="choices">
        <label><input type="radio" name="wordA" value="開始" checked>開始<span class="en">Start</span></label>
        <label><input type="radio" name="wordA" value="運動">運動<span class="en">Workout</span></label>
        <label><input type="radio" name="wordA" value="發射">發射<span class="en">Launch</span></label>
        <label><input type="radio" name="wordA" value="自訂">自訂<span class="en">Custom</span></label>
      </div>
      <div class="time-input" style="margin-top:6px"><input id="customA" type="text" placeholder="自訂詞 / Custom word" style="flex:1; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:#0c1430; color:var(--ink)"></div>

      <div class="display" id="dispA">00:20</div>
      <div class="pill" style="font-size:16px;">狀態：<span id="nowA" style="font-weight:700;">停止</span> <span class="en">&nbsp;Status</span></div>
    </div>

    <!-- B -->
    <div class="card" id="cardB">
      <h2>第二組（B） <span class="en">Timer B</span> <span class="badge" id="badgeB">待命<span class="en"> Ready</span></span></h2>
      <div class="section-title">時間（MM:SS）<span class="en">Duration (MM:SS)</span></div>
      <div class="slider-row">
        <span class="pill">分鐘 / Min</span>
        <input id="minBSlider" type="range" min="0" max="99" step="1">
        <span class="val" id="minBVal">00</span>
      </div>
      <div class="slider-row">
        <span class="pill">秒 / Sec</span>
        <input id="secBSlider" type="range" min="0" max="59" step="1">
        <span class="val" id="secBVal">10</span>
      </div>
      <div class="time-input"><input id="minB" type="number" min="0" max="99" value="00"><span>:</span><input id="secB" type="number" min="0" max="59" value="10"></div>

      <div class="section-title">嗶聲起點（剩餘秒）<span class="en">Beep when ≤ seconds left</span></div>
      <div class="slider-row">
        <span class="pill">嗶聲 / Beep</span>
        <input id="beepBSlider" type="range" min="1" max="10" step="1">
        <span class="val"><span id="beepBVal">5</span>s</span>
      </div>
      <div class="pill" style="margin-top:6px">數字輸入 / Box <input id="beepB" type="number" min="0" max="60" value="5" style="width:64px;margin-left:8px;"></div>

      <div class="section-title">到時播報詞（在「A 組」結束時播）<span class="en">End speech (spoken when A ends)</span></div>
      <div class="choices">
        <label><input type="radio" name="wordB" value="休息" checked>休息<span class="en">Rest</span></label>
        <label><input type="radio" name="wordB" value="暫停">暫停<span class="en">Pause</span></label>
        <label><input type="radio" name="wordB" value="恢復">恢復<span class="en">Recover</span></label>
        <label><input type="radio" name="wordB" value="自訂">自訂<span class="en">Custom</span></label>
      </div>
      <div class="time-input" style="margin-top:6px"><input id="customB" type="text" placeholder="自訂詞 / Custom word" style="flex:1; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:#0c1430; color:var(--ink)"></div>

      <div class="display" id="dispB">00:10</div>
      <div class="pill" style="font-size:16px;">狀態：<span id="nowB" style="font-weight:700;">停止</span> <span class="en">&nbsp;Status</span></div>
    </div>
  </div>

  <div class="footer">
    聲音/語音需先有一次按鈕互動；高精度計時避免飄移；螢幕常亮需支援 Wake Lock API；PWA 需要 HTTPS 服務環境。<span class="en">Audio/Speech require first user interaction. High-precision timing. Wake Lock requires API support. PWA needs HTTPS hosting.</span>
  </div>
</div>

<script>
(() => {
  // ==== Utils ====
  const clamp=(v,min,max)=>Math.max(min,Math.min(max, v|0));
  const pad2=n=>String(n).padStart(2,'0');
  const el=id=>document.getElementById(id);
  const save=(k,v)=>localStorage.setItem(k, JSON.stringify(v));
  const load=(k,def)=>{ try{ const x=JSON.parse(localStorage.getItem(k)); return x ?? def; }catch{ return def; } };
  const fmt=(secs)=>{ secs=Math.max(0,secs|0); const m=Math.floor(secs/60), s=secs%60; return pad2(m)+':'+pad2(s); };

  // ==== Audio ====
  let audioCtx=null,lastBeepAt=0;
  function ensureAudio(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }
  function beep(){
    if(!audioCtx) return;
    const now=performance.now(); if(now-lastBeepAt<120) return; lastBeepAt=now;
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='square'; o.frequency.value=1000; g.gain.value=0.0001; o.connect(g).connect(audioCtx.destination);
    const t=audioCtx.currentTime; g.gain.exponentialRampToValueAtTime(0.25,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18);
    o.start(t); o.stop(t+0.2);
  }
  function speak(text){ if(!text) return; const u=new SpeechSynthesisUtterance(text); u.lang='zh-TW'; u.rate=1.0; u.pitch=1.0; speechSynthesis.cancel(); speechSynthesis.speak(u); }
  function vib(p){ if(!el('vibrateChk').checked) return; if(navigator.vibrate) navigator.vibrate(p); }

  // ==== Wake Lock ====
  let wakeLock=null;
  async function requestWake(){
    if(!('wakeLock' in navigator)) return false;
    try{
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener?.('release', ()=>{ /* auto released */ });
      return true;
    }catch(e){ return false; }
  }
  async function releaseWake(){ try{ await wakeLock?.release(); }catch{} finally{ wakeLock=null; } }
  el('wakeChk').addEventListener('change', async ()=>{
    if(el('wakeChk').checked){ const ok=await requestWake(); if(!ok){ el('wakeChk').checked=false; alert('此裝置/瀏覽器不支援螢幕常亮 Wake Lock。'); } }
    else { await releaseWake(); }
  });
  document.addEventListener('visibilitychange', async ()=>{ // re-acquire on visibility return
    if(document.visibilityState==='visible' && el('wakeChk').checked){ await requestWake(); }
  });

  // ==== DOM refs ====
  const minA=el('minA'), secA=el('secA'), dispA=el('dispA'), nowA=el('nowA'), beepA=el('beepA'), badgeA=el('badgeA');
  const minB=el('minB'), secB=el('secB'), dispB=el('dispB'), nowB=el('nowB'), beepB=el('beepB'), badgeB=el('badgeB');
  const customA=el('customA'), customB=el('customB');
  const startBtn=el('startBtn'), pauseBtn=el('pauseBtn'), resetBtn=el('resetBtn'), who=el('who');
  const roundsDoneEl=el('roundsDone'), roundsGoalEl=el('roundsGoal');
  const phaseRemainEl=el('phaseRemain'), totalRemainEl=el('totalRemain');

  const roundsSlider=el('roundsSlider'), roundsVal=el('roundsVal'), autoStopChk=el('autoStopChk');
  const longEveryN=el('longEveryN'), longMin=el('longMin'), longSec=el('longSec');
  const minASlider=el('minASlider'), secASlider=el('secASlider'), minAVal=el('minAVal'), secAVal=el('secAVal');
  const minBSlider=el('minBSlider'), secBSlider=el('secBSlider'), minBVal=el('minBVal'), secBVal=el('secBVal');
  const beepASlider=el('beepASlider'), beepAVal=el('beepAVal');
  const beepBSlider=el('beepBSlider'), beepBVal=el('beepBVal');
  const longMinSlider=el('longMinSlider'), longSecSlider=el('longSecSlider'), longMinVal=el('longMinVal'), longSecVal=el('longSecVal');

  const recipeSelect=el('recipeSelect'), recipeName=el('recipeName');
  const saveRecipeBtn=el('saveRecipe'), delRecipeBtn=el('deleteRecipe'), startRecipeBtn=el('startRecipe');

  // ==== Words ====
  function selectedWord(group){
    const name=group==='A'?'wordA':'wordB';
    const val=(document.querySelector(`input[name="${name}"]:checked`)||{}).value;
    if(val==='自訂') return (group==='A'?customA.value:customB.value)||'完成';
    return val||'完成';
  }

  // ==== Values ====
  const fix2=inp=>{ inp.addEventListener('change',()=>{ let v=clamp(inp.value, +inp.min, +inp.max); inp.value=pad2(v); saveAll(); updateDisplays(); }); };
  [minA,secA,minB,secB,longMin,longSec].forEach(fix2);
  [minA,secA,minB,secB,beepA,beepB,customA,customB,longEveryN,longMin,longSec].forEach(e=>e.addEventListener('input', ()=>{ saveAll(); updateDisplays(); }));
  document.querySelectorAll('input[name="wordA"],input[name="wordB"]').forEach(r=>r.addEventListener('change', saveAll));
  autoStopChk.addEventListener('change', ()=>{ saveAll(); syncGoal(); });

  function bindPair(numEl, sliderEl, valEl, pad=true){
    const syncFromNum=()=>{ const v=clamp(numEl.value, +numEl.min, +numEl.max); sliderEl.value=v; if(valEl) valEl.textContent=pad?pad2(v):v; saveAll(); updateDisplays(); };
    const syncFromSlider=()=>{ const v=+sliderEl.value; numEl.value=pad?pad2(v):v; if(valEl) valEl.textContent=pad?pad2(v):v; saveAll(); updateDisplays(); };
    numEl.addEventListener('input', syncFromNum);
    sliderEl.addEventListener('input', syncFromSlider);
    sliderEl.value=clamp(numEl.value, +sliderEl.min, +sliderEl.max);
    if(valEl) valEl.textContent=pad?pad2(sliderEl.value):sliderEl.value;
  }
  bindPair(minA, minASlider, minAVal, true);
  bindPair(secA, secASlider, secAVal, false);
  bindPair(minB, minBSlider, minBVal, true);
  bindPair(secB, secBSlider, secBVal, false);
  function bindBeep(numEl, sliderEl, valEl){
    const syncFromNum=()=>{ let v=clamp(numEl.value, 0, 60); numEl.value=v; if(v!==0 && v<1){ v=1; numEl.value=1; }
      sliderEl.value=clamp(v||1, +sliderEl.min, +sliderEl.max); valEl.textContent=sliderEl.value; saveAll(); };
    const syncFromSlider=()=>{ const v=+sliderEl.value; numEl.value=v; valEl.textContent=v; saveAll(); };
    numEl.addEventListener('input', syncFromNum); sliderEl.addEventListener('input', syncFromSlider);
    sliderEl.value=clamp(numEl.value||5, +sliderEl.min, +sliderEl.max); valEl.textContent=sliderEl.value;
  }
  bindBeep(beepA, beepASlider, beepAVal);
  bindBeep(beepB, beepBSlider, beepBVal);
  function bindRounds(){
    const syncFromNum=()=>{ let v=clamp(roundsSlider.value,1,99); roundsVal.textContent=v; saveAll(); syncGoal(); };
    roundsSlider.addEventListener('input', syncFromNum);
    roundsSlider.value=8; roundsVal.textContent='8';
  }
  bindRounds();
  function bindLongSliders(){
    const syncMin=()=>{ longMin.value=pad2(clamp(longMinSlider.value,0,99)); longMinVal.textContent=pad2(longMinSlider.value); saveAll(); updateDisplays(); };
    const syncSec=()=>{ longSec.value=pad2(clamp(longSecSlider.value,0,59)); longSecVal.textContent=pad2(longSecSlider.value); saveAll(); updateDisplays(); };
    longMinSlider.addEventListener('input', syncMin);
    longSecSlider.addEventListener('input', syncSec);
    longMinSlider.value=0; longSecSlider.value=0; longMinVal.textContent='00'; longSecVal.textContent='00';
  }
  bindLongSliders();

  // ==== Timer state ====
  let timer={ current:null, running:false, endTs:0, remainMs:0, rafId:null, lastWhole:null, roundsDone:0, roundsGoal:Infinity, longEvery:0 };
  function otherGroup(g){ return g==='A'?'B':'A'; }

  function totalSecsOf(group){
    if(group==='A') return clamp(minA.value,0,99)*60 + clamp(secA.value,0,59);
    if(group==='B') return clamp(minB.value,0,99)*60 + clamp(secB.value,0,59);
    if(group==='LONG') return clamp(longMin.value,0,99)*60 + clamp(longSec.value,0,59);
    return 0;
  }
  function beepStart(g){ return clamp(g==='A'?beepA.value:beepB.value,0,60); }
  function setDisplay(g, secs){ (g==='A'?dispA:dispB).textContent = fmt(secs); }
  function setState(g, text, active=false){
    (g==='A'?nowA:nowB).textContent = text.replace(' / ','');
    (g==='A'?badgeA:badgeB).textContent = active ? '計時中 / Running' : (text.includes('停止')?'待命 / Ready':text);
  }
  function syncGoal(){ timer.roundsGoal = el('autoStopChk').checked ? (+roundsSlider.value|0) : Infinity;
    roundsGoalEl.textContent = isFinite(timer.roundsGoal) ? timer.roundsGoal : '∞'; }

  function startCycle(){ ensureAudio(); syncGoal(); if(timer.running) return;
    timer.roundsDone=0; roundsDoneEl.textContent='0'; timer.longEvery=clamp(longEveryN.value,0,999);
    timer.current='A'; who.textContent='A 組 / Timer A'; setState('A','啟動 / Start',true); setState('B','待命 / Ready',false);
    runTimerFor('A', totalSecsOf('A')); startBtn.disabled=true; pauseBtn.disabled=false; }

  function maybeInsertLongRest(){
    if(timer.longEvery>0 && timer.roundsDone>0 && (timer.roundsDone % timer.longEvery === 0)){
      const lr = totalSecsOf('LONG'); if(lr>0){ timer.current='LONG'; who.textContent='長休息 / Long Rest'; runTimerFor('LONG', lr, true); return true; }
    } return false;
  }
  function switchNext(){
    if(timer.current==='LONG'){ timer.current='A'; who.textContent='A 組 / Timer A'; runTimerFor('A', totalSecsOf('A')); return; }
    timer.current = otherGroup(timer.current); who.textContent = (timer.current==='A'?'A 組 / Timer A':'B 組 / Timer B');
    runTimerFor(timer.current, totalSecsOf(timer.current));
  }

  function runTimerFor(group, secs, noSwapSpeech=false){
    if(secs<=0){
      if(group==='LONG'){ switchNext(true); return; }
      if(!noSwapSpeech){ const tgt=otherGroup(group); speak(selectedWord(tgt)); vib([50,70,50]); }
      if(group==='B'){
        timer.roundsDone++; roundsDoneEl.textContent=String(timer.roundsDone);
        if(timer.roundsDone>=timer.roundsGoal){ stopAll(); return; }
        if(maybeInsertLongRest()) return;
      }
      switchNext(); return;
    }
    timer.running=true; timer.lastWhole=null; timer.endTs=performance.now()+secs*1000; timer.remainMs=secs*1000;
    if(group==='A'){ badgeA.textContent='計時中 / Running'; badgeB.textContent='待命 / Ready'; }
    else if(group==='B'){ badgeB.textContent='計時中 / Running'; badgeA.textContent='待命 / Ready'; }
    setState(group,'計時中 / Running',true);
    cancelAnimationFrame(timer.rafId);
    tick(noSwapSpeech);
  }

  function calcTotalRemainingSeconds(currentWhole){
    // currentWhole: ceil(remaining of current phase)
    // Remaining inside this round:
    const other = otherGroup(timer.current);
    let total = 0;
    if(timer.current==='A' || timer.current==='B'){
      total += currentWhole; // current phase
      // after current phase, we will switch to other (unless current is B and long rest logic triggers after updating rounds)
      if(timer.current==='A'){
        total += totalSecsOf('B');
      } else if(timer.current==='B'){
        // finishing B adds a round; potential long rest may trigger depending on next count
        const nextRoundsDone = timer.roundsDone + 1;
        if(isFinite(timer.roundsGoal) && nextRoundsDone >= timer.roundsGoal){
          // stops after finishing this B; no further time
        } else {
          // maybe long rest
          if(timer.longEvery>0 && (nextRoundsDone % timer.longEvery === 0)){
            total += totalSecsOf('LONG');
          }
          total += totalSecsOf('A');
        }
      }
      // Remaining full future rounds after current round:
      let remainingRounds;
      if(isFinite(timer.roundsGoal)){
        const currentRoundIndex = (timer.current==='B') ? (timer.roundsDone + 1) : timer.roundsDone; // if in B, we're within this round; finishing B completes it
        remainingRounds = Math.max(0, timer.roundsGoal - currentRoundIndex);
      } else {
        remainingRounds = 0; // infinite case: don't show huge infinity; stick to within current/next
      }
      const perRound = totalSecsOf('A') + totalSecsOf('B');
      const longEvery = timer.longEvery>0 ? timer.longEvery : Infinity;
      if(remainingRounds>0){
        // count how many long rests will occur in the future remaining rounds
        const doneAfterCurrent = (timer.current==='B') ? (timer.roundsDone + 1) : timer.roundsDone;
        const finalRoundCount = doneAfterCurrent + remainingRounds;
        let longCount = 0;
        if(isFinite(longEvery) && totalSecsOf('LONG')>0){
          // count multiples of longEvery between (doneAfterCurrent+1 .. finalRoundCount)
          const first = doneAfterCurrent + 1;
          for(let r=first; r<=finalRoundCount; r++){
            if(r % longEvery === 0) longCount++;
          }
        }
        total += remainingRounds * perRound + longCount * totalSecsOf('LONG');
      }
    } else if(timer.current==='LONG'){
      total += currentWhole + totalSecsOf('A') + totalSecsOf('B') * (isFinite(timer.roundsGoal) ? Math.max(0, timer.roundsGoal - timer.roundsDone) : 0);
    }
    return total;
  }

  function tick(noSwapSpeech=false){
    if(!timer.running) return;
    const now=performance.now(); let remain=Math.max(0, timer.endTs-now); timer.remainMs=remain;
    const whole=Math.ceil(remain/1000), group=timer.current;

    // This-phase remain display:
    phaseRemainEl.textContent = fmt(whole);

    if(group==='A'||group==='B') setDisplay(group, Math.max(0,whole));
    if((group==='A'||group==='B') && timer.lastWhole!==null && whole!==timer.lastWhole){
      const threshold=beepStart(group);
      if(whole>0 && whole<=threshold){ beep(); vib(25); }
    }
    timer.lastWhole=whole;

    // Total remaining:
    totalRemainEl.textContent = fmt(calcTotalRemainingSeconds(whole));

    if(remain<=0){
      if(group==='LONG'){ switchNext(true); return; }
      if(!noSwapSpeech){ const tgt=otherGroup(group); speak(selectedWord(tgt)); vib([60,80,60]); }
      if(group==='B'){
        timer.roundsDone++; roundsDoneEl.textContent=String(timer.roundsDone);
        if(timer.roundsDone>=timer.roundsGoal){ stopAll(); return; }
        if(maybeInsertLongRest()) return;
      }
      switchNext(); return;
    }
    timer.rafId=requestAnimationFrame(()=>tick(noSwapSpeech));
  }

  function pause(){ if(!timer.running) return; timer.running=false; cancelAnimationFrame(timer.rafId);
    setState(timer.current,'已暫停 / Paused',false); el('pauseBtn').textContent='繼續 / Resume'; }
  function resume(){ if(timer.running) return; ensureAudio(); timer.running=true; timer.endTs=performance.now()+timer.remainMs;
    setState(timer.current,'計時中 / Running',true); el('pauseBtn').textContent='暫停 / Pause'; tick(); }
  function stopAll(){
    timer.running=false; cancelAnimationFrame(timer.rafId); who.textContent='完成 / Done';
    startBtn.disabled=false; pauseBtn.disabled=true; el('pauseBtn').textContent='暫停 / Pause'; speechSynthesis.cancel();
    badgeA.textContent='待命 / Ready'; badgeB.textContent='待命 / Ready'; setState('A','停止 / Stopped',false); setState('B','停止 / Stopped',false);
    phaseRemainEl.textContent='00:00'; totalRemainEl.textContent='00:00';
  }
  function resetAll(){
    timer.running=false; cancelAnimationFrame(timer.rafId); timer.current=null; timer.remainMs=0; timer.roundsDone=0; roundsDoneEl.textContent='0';
    who.textContent='—'; setDisplay('A', totalSecsOf('A')); setDisplay('B', totalSecsOf('B'));
    setState('A','停止 / Stopped',false); setState('B','停止 / Stopped',false);
    badgeA.textContent='待命 / Ready'; badgeB.textContent='待命 / Ready';
    startBtn.disabled=false; pauseBtn.disabled=true; el('pauseBtn').textContent='暫停 / Pause'; speechSynthesis.cancel();
    phaseRemainEl.textContent='00:00'; totalRemainEl.textContent='00:00'; syncGoal();
  }

  startBtn.addEventListener('click', startCycle);
  pauseBtn.addEventListener('click', ()=>{ if(timer.running) pause(); else resume(); });
  resetBtn.addEventListener('click', resetAll);
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden && timer.running) pause(); });

  function updateDisplays(){ setDisplay('A', totalSecsOf('A')); setDisplay('B', totalSecsOf('B')); }

  // ==== Save/Load settings ====
  function saveAll(){
    const data={
      minA:minA.value, secA:secA.value, beepA:beepA.value,
      minB:minB.value, secB:secB.value, beepB:beepB.value,
      wordA:(document.querySelector('input[name="wordA"]:checked')||{}).value,
      wordB:(document.querySelector('input[name="wordB"]:checked')||{}).value,
      customA:customA.value, customB:customB.value,
      vibrate:el('vibrateChk').checked,
      rounds:roundsSlider.value, autoStop:autoStopChk.checked,
      longEvery:longEveryN.value, longMin:longMin.value, longSec:longSec.value
    };
    save('dualTimers_settings', data);
  }
  function loadAll(){
    const d=load('dualTimers_settings', null);
    if(!d){ roundsSlider.value=8; roundsVal.textContent='8'; syncGoal(); return; }
    minA.value=d.minA??'00'; secA.value=d.secA??'20'; beepA.value=d.beepA??'5';
    minB.value=d.minB??'00'; secB.value=d.secB??'10'; beepB.value=d.beepB??'5';
    ['A','B'].forEach(g=>{ const v=d['word'+g]; if(v){ const r=document.querySelector(`input[name="word${g}"][value="${v}"]`); if(r) r.checked=true; }});
    customA.value=d.customA??''; customB.value=d.customB??'';
    el('vibrateChk').checked=!!d.vibrate;
    roundsSlider.value=d.rounds??'8'; roundsVal.textContent=roundsSlider.value; autoStopChk.checked=!!d.autoStop;
    longEveryN.value=d.longEvery??0; longMin.value=d.longMin??'00'; longSec.value=d.longSec??'00';
    // sync slider labels
    minASlider.value=clamp(minA.value,0,99); minAVal.textContent=pad2(minASlider.value);
    secASlider.value=clamp(secA.value,0,59); secAVal.textContent=secASlider.value;
    minBSlider.value=clamp(minB.value,0,99); minBVal.textContent=pad2(minBSlider.value);
    secBSlider.value=clamp(secB.value,0,59); secBVal.textContent=secBSlider.value;
    beepASlider.value=clamp(beepA.value||5,1,10); beepAVal.textContent=beepASlider.value;
    beepBSlider.value=clamp(beepB.value||5,1,10); beepBVal.textContent=beepBSlider.value;
    longMinSlider.value=clamp(longMin.value,0,99); longMinVal.textContent=pad2(longMinSlider.value);
    longSecSlider.value=clamp(longSec.value,0,59); longSecVal.textContent=pad2(longSecSlider.value);
    updateDisplays(); syncGoal();
  }
  loadAll();

  // ==== Recipes CRUD with defaults (bilingual names) ====
  function getRecipe(){ return {
    name: recipeName.value.trim() || 'Untitled',
    A:{m:+minA.value, s:+secA.value, beep:+beepA.value, word:(document.querySelector('input[name="wordA"]:checked')||{}).value||'開始', custom:customA.value||''},
    B:{m:+minB.value, s:+secB.value, beep:+beepB.value, word:(document.querySelector('input[name="wordB"]:checked')||{}).value||'休息', custom:customB.value||''},
    rounds:+roundsSlider.value, autoStop:autoStopChk.checked,
    longEvery:+longEveryN.value, long:{m:+longMin.value, s:+longSec.value}
  };}
  function applyRecipe(r){
    minA.value=pad2(r.A.m); secA.value=pad2(r.A.s); beepA.value=r.A.beep;
    minB.value=pad2(r.B.m); secB.value=pad2(r.B.s); beepB.value=r.B.beep;
    (document.querySelector(`input[name="wordA"][value="${r.A.word}"]`)||document.querySelector(`input[name="wordA"][value="自訂"]`)).checked=true;
    (document.querySelector(`input[name="wordB"][value="${r.B.word}"]`)||document.querySelector(`input[name="wordB"][value="自訂"]`)).checked=true;
    customA.value=r.A.custom||''; customB.value=r.B.custom||'';
    roundsSlider.value=r.rounds; roundsVal.textContent=r.rounds; autoStopChk.checked=!!r.autoStop;
    longEveryN.value=r.longEvery||0; longMin.value=pad2(r.long?.m||0); longSec.value=pad2(r.long?.s||0);
    // reflect to sliders/labels
    loadAll(); recipeName.value=r.name||'';
  }
  function loadRecipes(){ return load('dualTimers_recipes', []); }
  function saveRecipes(list){ save('dualTimers_recipes', list); }
  function refreshRecipeSelect(){
    const list=loadRecipes(); recipeSelect.innerHTML='';
    if(list.length===0){ const opt=document.createElement('option'); opt.value=''; opt.textContent='（無配方） / (No recipes)'; recipeSelect.appendChild(opt); return; }
    list.forEach((r,i)=>{ const opt=document.createElement('option'); opt.value=String(i); opt.textContent=r.name; recipeSelect.appendChild(opt); });
  }
  function saveOrOverwriteRecipe(){
    const now=getRecipe(); const list=loadRecipes(); const idx=recipeSelect.value?parseInt(recipeSelect.value,10):-1;
    if(idx>=0 && list[idx]) list[idx]=now; else list.push(now);
    saveRecipes(list); refreshRecipeSelect(); const ni=list.findIndex(x=>x.name===now.name); recipeSelect.value=String(ni>=0?ni:0);
  }
  function deleteRecipe(){ const list=loadRecipes(); const idx=parseInt(recipeSelect.value||'-1',10); if(isNaN(idx)||!list[idx]) return;
    list.splice(idx,1); saveRecipes(list); refreshRecipeSelect(); recipeName.value=''; }
  recipeSelect.addEventListener('change', ()=>{ const list=loadRecipes(); const idx=parseInt(recipeSelect.value||'-1',10); if(!isNaN(idx)&&list[idx]) applyRecipe(list[idx]); });
  saveRecipeBtn.addEventListener('click', saveOrOverwriteRecipe);
  delRecipeBtn.addEventListener('click', deleteRecipe);
  startRecipeBtn.addEventListener('click', ()=>{ const list=loadRecipes(); const idx=parseInt(recipeSelect.value||'-1',10); if(!isNaN(idx)&&list[idx]) applyRecipe(list[idx]); startCycle(); });

  (function seedDefaults(){
    let seeded = load('dualTimers_seeded', false);
    if(!seeded){
      const defaults=[
        { // 1. Archery SPT（弓箭 SPT：長持+短休 的基礎輪）
          name:'Archery SPT × 6（弓箭強度訓練） / Archery SPT × 6',
          A:{m:2,s:0,beep:10,word:'開始',custom:''},   // 2:00 拉持
          B:{m:0,s:45,beep:5,word:'休息',custom:''},   // 0:45 休息
          rounds:6, autoStop:true, longEvery:0, long:{m:0,s:0}
        },
        { // 2. Tabata
          name:'Tabata 20/10 × 8（間歇訓練） / Tabata 20/10 × 8',
          A:{m:0,s:20,beep:5,word:'開始',custom:''},
          B:{m:0,s:10,beep:5,word:'休息',custom:''},
          rounds:8, autoStop:true, longEvery:0, long:{m:0,s:0}
        },
        { // 3. 番茄鐘
          name:'番茄鐘 25/5 × 4 + 長休10 / Pomodoro 25/5 × 4 + LR10',
          A:{m:25,s:0,beep:10,word:'發射',custom:''},
          B:{m:5,s:0,beep:5,word:'休息',custom:''},
          rounds:4, autoStop:true, longEvery:4, long:{m:10,s:0}
        },
        { // 4. EMOM
          name:'EMOM 40/20 × 10（每分鐘工作） / EMOM 40/20 × 10',
          A:{m:0,s:40,beep:5,word:'開始',custom:''},
          B:{m:0,s:20,beep:5,word:'休息',custom:''},
          rounds:10, autoStop:true, longEvery:0, long:{m:0,s:0}
        }
      ];
      saveRecipes(defaults); save('dualTimers_seeded', true);
      refreshRecipeSelect(); recipeSelect.value='0'; applyRecipe(defaults[0]);
    } else {
      refreshRecipeSelect();
      if(recipeSelect.options.length>0) recipeSelect.value='0';
    }
  })();

  // ==== Layout auto + manual ====
  const layoutSelect = document.getElementById('layoutSelect');
  function applyLayout(mode){
    document.body.classList.remove('portrait','landscape');
    if(mode==='portrait') document.body.classList.add('portrait');
    else if(mode==='landscape') document.body.classList.add('landscape');
    else { // auto
      const isPortrait = window.matchMedia('(orientation: portrait)').matches;
      // also consider width threshold
      const wide = window.innerWidth >= 900;
      if(isPortrait && !wide) document.body.classList.add('portrait');
      else document.body.classList.add('landscape');
    }
    save('dualTimers_layoutMode', mode);
  }
  layoutSelect.addEventListener('change', ()=>applyLayout(layoutSelect.value));
  window.addEventListener('resize', ()=>{ if(layoutSelect.value==='auto') applyLayout('auto'); });
  (function initLayout(){
    const saved = load('dualTimers_layoutMode','auto'); layoutSelect.value=saved; applyLayout(saved);
  })();

  // ==== PWA (manifest + SW) ====
  (function setupPWA(){
    const pwaStatus = el('pwaStatus');
    if(location.protocol!=='https:'){
      pwaStatus.textContent = 'PWA：需 HTTPS 伺服器才能安裝 / Needs HTTPS to install';
      return;
    }
    // Create a minimal manifest at runtime
    const manifest = {
      name: "Dual Timers · Recipes",
      short_name: "DualTimers",
      start_url: location.pathname + location.search,
      display: "standalone",
      background_color: "#0b1020",
      theme_color: "#0b1020",
      icons: []
    };
    const blob = new Blob([JSON.stringify(manifest)], {type:'application/json'});
    const murl = URL.createObjectURL(blob);
    const link = document.createElement('link');
    link.rel='manifest'; link.href=murl; document.head.appendChild(link);

    // Simple SW via Blob
    const swCode = `
      self.addEventListener('install', e=>{
        self.skipWaiting();
      });
      self.addEventListener('activate', e=>{
        e.waitUntil(self.clients.claim());
      });
      self.addEventListener('fetch', e=>{
        // Network-first passthrough; could be enhanced to cache.
      });
    `;
    const swBlob = new Blob([swCode], {type:'text/javascript'});
    const swUrl = URL.createObjectURL(swBlob);
    if('serviceWorker' in navigator){
      navigator.serviceWorker.register(swUrl).then(()=>{
        pwaStatus.textContent = 'PWA：可安裝（於瀏覽器選單） / Installable';
      }).catch(()=>{
        pwaStatus.textContent = 'PWA：註冊失敗 / SW registration failed';
      });
    } else {
      pwaStatus.textContent = 'PWA：不支援 / Not supported';
    }
  })();

})();
</script>
</body>
</html>
